package com.evoMusic.model.geneticAlgorithm.blending.multiMarkov;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.Vector;

import jm.music.data.Note;
import jm.music.data.Part;
import jm.music.data.Score;

import com.evoMusic.model.Song;
import com.evoMusic.model.Track;
import com.evoMusic.model.geneticAlgorithm.blending.IntervalSong;
import com.evoMusic.model.geneticAlgorithm.blending.IntervalTrack;
import com.evoMusic.model.geneticAlgorithm.blending.MarkovTrack;
import com.evoMusic.model.geneticAlgorithm.blending.ProbabilityMatrix;
import com.evoMusic.model.geneticAlgorithm.blending.multiMarkov.StateSong.TrackProperties;
import com.evoMusic.util.TrackTag;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;

public class MarkovStateMachine {

    private ProbabilityMatrix<TempState<Integer>, TempState<Integer>> intervalMatrix;
    private ProbabilityMatrix<TempState<Integer>, TempState<Double>> rhythmValueMatrix;
    private ProbabilityMatrix<TempState<Integer>, TempState<Double>> durationMatrix;
    private ProbabilityMatrix<TempState<Integer>, TempState<Integer>> dynamicMatrix;
    private ProbabilityMatrix<TempState<Integer>, TempState<Double>> timeDeltaMatrix;
    private int numberOfLookbacks;
    private Random rand;
    private ArrayList<StateSong> intervalledSongs;
    private int numberOfTracks;
    private int[] firstNotes;
    private List<TrackProperties> trackProperties;

    /**
     * Creates a markov chain containing a probability matrix for each property
     * in a track that.
     * 
     * @param lookbacks
     */
    public MarkovStateMachine(int lookbacks, List<Song> songs) {
        this.numberOfLookbacks = lookbacks;
        this.intervalMatrix = new ProbabilityMatrix<TempState<Integer>, TempState<Integer>>();
        this.rhythmValueMatrix = new ProbabilityMatrix<TempState<Integer>, TempState<Double>>();
        this.durationMatrix = new ProbabilityMatrix<TempState<Integer>, TempState<Double>>();
        this.dynamicMatrix = new ProbabilityMatrix<TempState<Integer>, TempState<Integer>>();
        this.timeDeltaMatrix = new ProbabilityMatrix<TempState<Integer>, TempState<Double>>();
        
        if (lookbacks < 0) {
            throw new IllegalArgumentException("Negative lookback value");
        }
        this.numberOfLookbacks = lookbacks;
        this.rand = new Random();
        this.intervalledSongs = new ArrayList<StateSong>();
        List<Song> trimmedSongs = trimSongParts(songs);
        for (Song currentSong : trimmedSongs) {
            intervalledSongs.add(new StateSong(currentSong));
        }
        numberOfTracks = intervalledSongs.get(0).numberOfTracks();
//        markovTracks = new ArrayList<MarkovTrack>(numberOfTracks);
        initProbabilityMatrices();
    }
    
    public void initTrackProperties() {
        IntervalSong newSong = new IntervalSong(getRandomTempo());

        // For each track.
        int numberOfSongs = intervalledSongs.size();
        StateSong randomSong = null;
        boolean chosenTrackIsEmpty;
        for (int trackIndex = 0; trackIndex < numberOfTracks; trackIndex++) {
            // make sure an empty track doesn't give their instruments etc.
            chosenTrackIsEmpty = true;
            while (chosenTrackIsEmpty) {
                randomSong = intervalledSongs.get(
                        (int) (rand.nextDouble() * numberOfSongs));
                chosenTrackIsEmpty = randomTrack.getIntervals().length == 0;
            }
            
            newSong.addTrack(markovTracks.get(trackIndex).generateNew(
                    songDuration, randomTrack.getInstrument(),
                    randomTrack.getChannel(), randomTrack.getFirstNote(), randomTrack.getTag()));
        }
        // TODO code here. Init track properties list and first notes.
    }

    /**
     * Generates a new song that is statistically alike to the songs given in
     * the constructor of this object. This method can be called several times
     * on the same instance and may return different songs each call.
     * 
     * @param songDuration
     *            The duration that the generated song will have.
     * @return A new song generated by merging the songs given in this objects
     *         constructor.
     */
    public void generateNew() {

        // TODO move javadoc.
    }
    
    

    /**
     * Generates an interval track from the probabilities in this markov chain.
     * 
     * @param songDuration
     *            The length of the track that will be generated.
     * @param instrument
     *            The instrument that the generated track should have.
     * @param channel
     *            The channel that the generated track should have.
     * @param firstNote
     *            The first note of the track that will be generated.
     * @return An interval track generated from the probabilities in this markov
     *         chain.
     */
    public Song generateNew(double songDuration) {
        
        List<TempState<Integer>> songIntervals = new ArrayList<TempState<Integer>>();
        List<TempState<Double>> songRhythmValues = new ArrayList<TempState<Double>>();
        List<TempState<Double>> songDurations = new ArrayList<TempState<Double>>();
        List<TempState<Integer>> songDynamics = new ArrayList<TempState<Integer>>();
        List<TempState<Double>> songTimeDeltas = new ArrayList<TempState<Double>>();
        
        int[] newFirstNotes = Arrays.copyOf(firstNotes, numberOfTracks);
        
        double currentLength = 0.0;
        boolean[] isResting = new boolean[numberOfTracks];
        Arrays.fill(isResting, false);
        Vector<TempState<Integer>> currentSequence;
        TempState<Integer> nextInterval;
        int currentTrack;
        
        TempState<Double> nextRhythmValue;
        TempState<Double> nextDuration;
        TempState<Integer> nextDynamic;
        TempState<Double> nextTimeDelta;

        while (currentLength < songDuration) {
            List<TempState<Integer>> currentIntervals = new ArrayList<TempState<Integer>>();
            List<TempState<Double>> currentRhythmValues = new ArrayList<TempState<Double>>();
            List<TempState<Double>> currentDurations = new ArrayList<TempState<Double>>();
            List<TempState<Integer>> currentDynamics = new ArrayList<TempState<Integer>>();
            List<TempState<Double>> currentTimeDeltas = new ArrayList<TempState<Double>>();

            for (int intervalIndex = 0; currentLength < songDuration; intervalIndex++) {
                currentSequence = getNextSequence(intervalIndex,
                        currentIntervals);
                nextInterval = intervalMatrix.getNext(currentSequence);
                if (nextInterval == null) {
                    break; // Has come to the end of the song, must start
                           // over.
                }
                currentTrack = nextInterval.trackIndex();
                // Make sure the first interval isn't a restback (high
                // positive number)
                if (currentLength == 0.0 && nextInterval.getValue() < -127) {
                    isResting[currentTrack] = true;
                    newFirstNotes[currentTrack] = Note.REST;
                } else {
                    // Make sure no dubbel rest/restback is added.
                    while (true) {
                        if (Math.abs(nextInterval.getValue()) < 127) {
                            break;
                        }
                        if (isResting[currentTrack] && nextInterval.getValue() > 127) {
                            isResting[currentTrack] = false;
                            break;
                        }
                        if ((!isResting[currentTrack]) && nextInterval.getValue() < -127) {
                            isResting[currentTrack] = true;
                            break;
                        }
                        nextInterval = intervalMatrix.getNext(currentSequence);
                    }
                }

                nextRhythmValue = rhythmValueMatrix.getNext(currentSequence);
                nextDuration = durationMatrix.getNext(currentSequence);
                nextDynamic = dynamicMatrix.getNext(currentSequence);
                nextTimeDelta = timeDeltaMatrix.getNext(currentSequence);
                
                currentLength += nextTimeDelta.getValue();
                
                currentIntervals.add(nextInterval);
                currentRhythmValues.add(nextRhythmValue);
                currentDurations.add(nextDuration);
                currentDynamics.add(nextDynamic);
                currentTimeDeltas.add(nextTimeDelta);
            }
            songIntervals.addAll(currentIntervals);
            songRhythmValues.addAll(currentRhythmValues);
            songDurations.addAll(currentDurations);
            songDynamics.addAll(currentDynamics);
            songTimeDeltas.addAll(currentTimeDeltas);
        }

        // TODO Make sure song is exact right length!!!
        
        // Adding the last rythmValues and durations.
//        double durationLeft = songDuration - trackLength;
//        nextRhythmValue = durationLeft;
//        nextDuration = durationLeft;
//
//        currentSequence = new Vector<Integer>();
//        for (int seqIndex = numberOfLookbacks; seqIndex > 0; seqIndex--) {
//            currentSequence.add(trackIntervals.get(trackIntervals.size()
//                    - seqIndex));
//        }
//        // nextRhythmValue = rhythmValueMatrix.getNext(currentSequence);
//        // nextDuration = durationMatrix.getNext(currentSequence);
//        nextDynamic = dynamicMatrix.getNext(currentSequence);
//        // trackLength += nextRhythmValue;
//        trackRhythmValues.add(nextRhythmValue);
//        trackDurations.add(nextDuration);
//        trackDynamics.add(nextDynamic);

        StateSong stateSong = new StateSong(getRandomTempo(), newFirstNotes, trackProperties, numberOfTracks, songIntervals, songRhythmValues, songDurations, songTimeDeltas, songDynamics);
        return stateSong.toSong();
    }
    
    /**
     * Gets a tempo value somewhere between the largest and the smallest tempo
     * of the songs given in this objects constructor.
     * 
     * @return A tempo between the tempo values of this instance's songs.
     */
    private double getRandomTempo() {
        // TODO Make more random.
        double tempo = 0;
        for (StateSong song : intervalledSongs) {
            tempo += song.getTempo();
        }
        return tempo / intervalledSongs.size();
    }

    /**
     * Initiates the probability matrices in this markov track. Call this method
     * sparingly, since it is relatively recource heavy.
     */
    public void initProbabilities() {
        intervalMatrix.initProbabilies();
        rhythmValueMatrix.initProbabilies();
        durationMatrix.initProbabilies();
    }

    /**
     * Gets the next sequence in the given sequence that is prior to the given
     * index
     * 
     * @param intervalIndex
     *            The index of the value that comes after the requested
     *            sequence.
     * @param currentIntervals
     *            The list of intervals that the sequence will be picked from.
     * @return
     */
    private Vector<TempState<Integer>> getNextSequence(int intervalIndex,
            List<TempState<Integer>> currentIntervals) {
        // TODO possible to optimize by fetching a previously cached sequence.
        int lookback;
        // Adding to sequence, wont add more than is available.
        Vector<TempState<Integer>> currentSequence = new Vector<TempState<Integer>>();
        for (int seqIndex = 0; seqIndex < numberOfLookbacks; seqIndex++) {
            lookback = intervalIndex - (numberOfLookbacks - seqIndex);
            if (lookback >= 0) {
                currentSequence.add(currentIntervals.get(lookback));

            }
        }
        return currentSequence;
    }
    
    /**
     * Trims and orders the songs in such way that it is guaranteed that all
     * songs has the same number of tracks and that all track with a certain
     * index has the same track tag. The original songs will not be modified,
     * but the new list will have references to the old tracks.
     * 
     * @param songList
     *            The song list that is to be trimmed.
     * @return A list of songs that all have identical structure.
     */
    private List<Song> trimSongParts(List<Song> songList) {
        Set<TrackTag> allTrackTags = new HashSet<TrackTag>();
        List<Song> trimmedSongs = new ArrayList<Song>();
        Iterator<TrackTag> tagIterator;
        TrackTag currentTag;
        // Finding all track tags.
        for (Song song : songList) {
            for (Track track : song.getTracks()) {
                if (!(track.getTag() == TrackTag.NONE) && track.getTag() != null) {
                    allTrackTags.add(track.getTag());
                }
            }
        }

        // Adding empty songs.
        Score newScore;
        for (Song song : songList) {
            newScore = new Score(song.getTempo());
            trimmedSongs.add(new Song(newScore));
        }

        tagIterator = allTrackTags.iterator();
        while (tagIterator.hasNext()) {
            currentTag = tagIterator.next();
            for (int songIndex = 0; songIndex < songList.size(); songIndex++) {
                Song song = songList.get(songIndex);
                boolean foundTrack = false;
                for (Track track : song.getTracks()) {
                    if (track.getTag() == currentTag) {
                        trimmedSongs.get(songIndex).addTrack(track);
                        foundTrack = true;
                    }
                }
                if (!foundTrack) {
                    trimmedSongs.get(songIndex).addTrack(
                            new Track(new Part(), currentTag));
                } else {
                    foundTrack = false;
                }
            }
        }        
        return trimmedSongs;

    }
    
    /**
     * Initiates the probability matrices for each song property in each track.
     * This is probably the most resource heavy method in this class.
     */
    private void initProbabilityMatrices() {
        List<TempState<Integer>> currentIntervals;
        List<TempState<Double>> currentRythmValues;
        List<TempState<Double>> currentDurations;
        List<TempState<Integer>> currentDynamics;
        List<TempState<Double>> currentTimeDeltas;

        Vector<TempState<Integer>> sequence;
        int currentIntervalsLength;

        for (StateSong currentStateSong : intervalledSongs) {
            currentIntervals = currentStateSong.getIntervals();
            currentRythmValues = currentStateSong.getRhythmValues();
            currentDurations = currentStateSong.getDurations();
            currentDynamics = currentStateSong.getDynamics();
            currentTimeDeltas = currentStateSong.getTimeDeltas();
            
            currentIntervalsLength = currentIntervals.size();
            
                for (int i = 0; i < currentIntervalsLength
                        - (numberOfLookbacks+1); i++) {
                    // Adding for empty sequences.
                    sequence = new Vector<TempState<Integer>>();
                    intervalMatrix.addCount(sequence,
                            currentIntervals.get(i));
                    
                    // Adding for longer sequences.
                    for (int j = i; j < i + numberOfLookbacks; j++) {
                        sequence = new Vector<TempState<Integer>>(sequence);
                        sequence.add(currentIntervals.get(j));
                        intervalMatrix.addCount(sequence,
                                currentIntervals.get(j+1));
                        rhythmValueMatrix.addCount(sequence,
                                currentRythmValues.get(j));
                        durationMatrix.addCount(sequence,
                                currentDurations.get(j));
                        dynamicMatrix.addCount(sequence, currentDynamics.get(j));
                        timeDeltaMatrix.addCount(sequence, currentTimeDeltas.get(j));
                    }

                }
                sequence = new Vector<TempState<Integer>>();
                for (int i = numberOfLookbacks; i > 0; i--) {
                    sequence.add(currentIntervals.get(currentIntervalsLength - i));
                }
                rhythmValueMatrix.addCount(sequence,
                        currentRythmValues.get(currentRythmValues.size() - 1));
                durationMatrix.addCount(sequence,
                        currentDurations.get(currentDurations.size() - 1));
                dynamicMatrix.addCount(sequence, currentDynamics.get(currentDynamics.size() - 1));
                timeDeltaMatrix.addCount(sequence, currentTimeDeltas.get(currentTimeDeltas.size() - 1));
        }
        intervalMatrix.initProbabilies();
        rhythmValueMatrix.initProbabilies();
        durationMatrix.initProbabilies();
        dynamicMatrix.initProbabilies();
        timeDeltaMatrix.initProbabilies();
        
    }

}
